# MySQL 索引

​	**MySQL官方对索引的定义为**：索引是帮助MySQL高效获取数据的数据结构。索引的本质：索引是数据结构，实现数据的数据的快速检索。



## **Mysql 索引数据结构**选型

### 哈希（Hash）（因范围查找 - 不适）

​	哈希算法：也叫散列算法，就是把任意值(key)通过哈希函数变换为固定长度的 key 地址，通过这个地址进行具体数据的数据结构。哈希算法有个**数据碰撞**的问题，也就是哈希函数可能对不同的 key 会计算出同一个结果，比如 hash(7)可能跟 hash(199)计算出来的结果一样，也就是不同的 key 映射到同一个结果。解决碰撞问题的一个常见处理方式就是链地址法，即用链表把碰撞的数据接连起来。计算哈希值之后，还需要检查该哈希值是否存在碰撞数据链表，有则一直遍历到链表尾，直达找到真正的 key 对应的数据为止。

​	从算法时间复杂度分析来看，哈希算法时间复杂度为 O（1），检索速度非常快。比如查找 id=7 的数据，哈希索引只需要计算一次就可以获取到对应的数据，检索速度非常快。<u>但是 Mysql 并没有采取哈希作为其底层算法，因为考虑到数据检索有一个常用手段就是范围查找</u>。

### 二叉查找树(BST)（因线性链表 - 不适）

​	二叉查找树的时间复杂度是 O(lgn)。但是普通的二叉查找树有个致命缺点：极端情况下会退化为**线性链表**，二分查找也会退化为遍历查找，时间复杂退化为 O（N），检索性能急剧下降。在数据库中，数据的自增是一个很常见的形式，比如一个表的主键是 id，而主键一般默认都是自增的，因此，简单的二叉查找树存在不平衡导致的检索性能降低的问题，是不能直接用于实现 Mysql 底层索引的。

### AVL 树和红黑树（因磁盘IO,右倾斜现象 - 不适）

​	二叉查找树存在不平衡问题，因此学者提出通过树节点的自动旋转和调整，让二叉树始终保持基本平衡的状态，就能保持二叉查找树的最佳查找性能了。基于这种思路的自调整平衡状态的二叉树有 AVL 树和红黑树。

​	红黑树，这是一颗会自动调整树形态的树结构，比如当二叉树处于一个不平衡状态时，红黑树就会自动左旋右旋节点以及节点变色，调整树的形态，使其保持基本的平衡状态（时间复杂度为 O（logn）），也就保证了查找效率不会明显减低。红黑树拥有不错的平均查找效率，也不存在极端的 O(n)情况。但是极端情况下会出现**右倾现象**，红黑树并没有完全解决二叉查找树虽然这个“右倾”趋势远没有二叉查找树退化为线性链表那么夸张，但是数据库中的基本主键自增操作，主键一般都是数百万数千万的，如果红黑树存在这种问题，对于查找性能而言也是巨大的消耗，我们数据库不可能忍受这种无意义的等待的。

​	 AVL 树是另一种更为严格的自平衡二叉树，因为 AVL 树是个绝对平衡的二叉树，可以解决右倾现象，因此在调整二叉树的形态上消耗的性能会更多。但是 AVL 树并不适合做 Mysql 数据库的索引数据结构，因为考虑一下这个问题：数据库查询数据的瓶颈在于**磁盘 IO**，如果使用的是 AVL 树，每一个树节点只存储了一个数据，一次磁盘 IO 只能取出来一个节点上的数据加载到内存里。磁盘 IO 有个有个特点，就是从磁盘读取 1B 数据和 1KB 数据所消耗的时间是基本一样的，设计数据库索引时需要首先考虑怎么尽可能减少磁盘 IO 的次数。、根据这个思路，可以在一个树节点上尽可能多地存储数据，一次磁盘 IO 就多加载点数据到内存，这就是 B 树，B+树的的设计原理了。

**B 树**

​	每个节点限制最多存储两个 key，一个节点如果超过两个 key 就会自动分裂。设置两个Key，存储了 7 个数据 B 树，两次磁盘 IO 就可以查询到指定数据，优于 AVL 树。存储了 16 个数据的 B 树，同样每个节点最多存储 2 个 key，需经过 4 次磁盘 IO。看起来查询性能与 AVL 树一样。考虑到磁盘 IO 读一个数据和读 100 个数据消耗的时间基本一致，那我们的优化思路就可以改为：尽可能在一次磁盘 IO 中多读一点数据到内存。这个直接反映到树的结构就是，每个节点能存储的 key 可以适当增加。B 树用作数据库索引有以下优点：优秀检索速度，时间复杂度：B 树的查找性能等于 O（h*logn），其中 h 为树高，n 为每个节点关键词的个数；尽可能少的磁盘 IO，加快了检索速度；可以支持范围查找。

### B+树

​	B 树一个节点里存的是数据，而 B+树存储的是索引（地址），所以 B 树里一个节点存不了很多个数据，但是 B+树一个节点能存很多索引，B+树叶子节点存所有的数据；B+树的叶子节点是数据阶段用了一个链表串联起来，便于范围查找。

​	B 树和 B+树的对比我们看出，B+树节点存储的是索引，在单个节点存储容量有限的情况下，单节点也能存储大量索引，使得整个 B+树高度降低，减少了磁盘 IO。其次，B+树的叶子节点是真正数据存储的地方，叶子节点用了链表连接起来，这个链表本身就是有序的，在数据范围查找时，更具备效率。因此 Mysql 的索引用的就是 B+树，B+树在查找效率、范围查找中都有着非常不错的性能。



## **Innodb 引擎和 MyISAM 引擎的实现**

Innodb 创建表后生成的文件有：

- frm:创建表的语句
- idb:表里面的数据+索引文件

MyISAM 创建表后生成的文件有

- frm:创建表的语句
- MYD:表里面的数据文件（myisam data）
- MYI:表里面的索引文件（myisam index）

​	从生成的文件看来，这两个引擎底层数据和索引的组织方式并不一样，MyISAM 引擎把数据和索引分开了，这叫做非聚集索引方式；Innodb 引擎把数据和索引放在同一个文件，这叫做聚集索引方式。

MyISAM 用的是非聚集索引方式，即数据和索引落在不同的两个文件上。MyISAM 在建表时以主键作为 KEY 来建立主索引 B+树，树的叶子节点存的是对应数据的物理地址。我们拿到这个物理地址后，就可以到 MyISAM 数据文件中直接定位到具体的数据记录。

​	InnoDB 是聚集索引方式，因此数据和索引都存储在同一个文件里。根据主键 ID 作为 KEY 建立索引 B+树。在`Innodb`中，聚簇索引默认就是主键索引。数据库表行中数据的物理顺序与键值的逻辑（索引）顺序相同。一个表的物理顺序只有一种情况，因此对应的聚集索引只能有一个。如果某索引不是聚集索引，则表中的行物理顺序与索引顺序不匹配，与非聚集索引相比，聚集索引有着更快的检索速度。如果表中没有定义主键，那么该表的第一个唯一非空索引被作为聚集索引。如果没有主键也没有合适的唯一索引，那么innodb内部会生成一个隐藏的主键作为聚集索引，这个隐藏的主键是一个6个字节的列，改列的值会随着数据的插入自增。于主键使用了聚集索引，如果主键是自增id，那么对应的数据一定也是相邻地存放在磁盘上的，写入性能比较高。如果是uuid的形式，频繁的插入会使innodb频繁地移动磁盘块，写入性能就比较低。



## 索引类型

​	从逻辑上，索引可以区分为

- 普通索引：普通索引是 MySQL 中最基本的索引类型，它没有任何限制，唯一任务就是加快系统对数据的访问速度。普通索引允许在定义索引的列中插入重复值和空值。
- 唯一索引：唯一索引与普通索引类似，不同的是创建唯一性索引的目的不是为了提高访问速度，而是为了避免数据出现重复。唯一索引列的值必须唯一，允许有空值。如果是组合索引，则列值的组合必须唯一。
- 主键索引：主键索引就是专门为主键字段创建的索引，也属于索引的一种。主键索引是一种特殊的唯一索引，不允许值重复或者值为空。
- 空间索引：空间索引是对空间数据类型的字段建立的索引，空间索引主要用于地理空间数据类型、。
- 全文索引：全文索引主要用来查找文本中的关键字，只能在 `CHAR、VARCHAR 或 TEXT` 类型的列上创建。在 `MySQL` 中只有 `MyISAM` 存储引擎支持全文索引。全文索引允许在索引列中插入重复值和空值。MYSQL 5.6.4 后 Innodb 也支持全文索引。
- 多列索引：也称为复合索引或组合索引。相对于单列索引来说，组合索引是将原表的多个列共同组成一个索引。该索引指向创建时对应的多个字段，可以通过这几个字段进行查询。但需遵循**最左匹配原则**。



## 索引失效

1. LIKE操作中，like name '%aaa%',则name索引会失效，但是like name ‘aaa%’是可以使用索引。
2. 使用 <>和 != 会失效(主键索引除外)，注意：在整形索引中使用<,>不会使索引失效。主键索引使用!=,>,<都不会失效。
3. 使用 or，但是没有把or中所有字段加上索引。
4. 对字段表达式或函数操作，会使索引失效。
5. 使用Not In 会导致索引失效。
6. 使用 is null 或者 is not null，当查询量达到总表的30%以上时，索引就会失效。
7. 在组合索引中某一索引列有null值，则索引失效。这句话其实是不对的，在单列索引中索引列有null值不会失效。在组合索引中索引列有null值也是可以使用组合索引的，MySQL难以优化引用了可空列的查询，它会使索引、索引统计和值更加复杂。可空列需要更多的储存空间，还需要在MySQL内部进行特殊处理。当可空列被索引的时候，每条记录都需要一个额外的字节，还可能导致 MyISAM 中固定大小的索引(例如一个整数列上的索引)变成可变大小的索引，所以尽量避免null值。尽量避免字段是null，尽量避免mysql where语句中出现null的判断
8. 如果排序使用了索引，而select列未使用索引列，则该索引失效，这是因为优化器执行直接执行全表扫描速度更快。主键索引除外，任何一张表都有一个唯一索引primary,索引列为主键列。在查询语句中where也使用了索引，order by 也使用了索引。这时where 中的索引生效，order by中的索引失效。当where中的索引失效后order by中的索引才会生效。
9. 组合索引最左原则问题。最左原则是指：mysql会一直向右匹配直到遇到范围查询(>、<、between、like)就停止匹配，索引可以任意顺序，mysql的查询优化器会优化优化where子句的条件顺序成索引可以识别的形式，让查询符合索引顺序，顺序颠倒后经过mysql优化器效率不会降低。
10. 组合索引是优先于单列索引。



## 回表

​	InnoDB索引由B+树构成，B+树由非叶子节点和叶子节点组成。非叶子节点不存储数据，而叶子节点存储数据。InnoDB中主键索引叶子节点存储的是整个表的行数据信息，称为聚簇索引，而非主键索引（也叫二级索引）的叶子节点存储的是主键的值（内存地址、指针）。

​	如果我们在表上为非主键创建索引时，相当于是维护了一棵二级索引的B+树，经过优化器判断后知道要查找该二级索引B+树。该B+树的非叶子节点存储的是索引字段的值，叶子节点存储的是主键索引B+树的值，查询过程就是两棵B+树（两次时间复杂度为O(logN)的查询过程）。二级索引的根据主键id到主键索引上的查询过程叫做回表。

​	如果是根据主键id查询那么就是直接查询主键B+树，时间复杂度是O(logN)。

​	如果查询的字段没有索引，那么就是在主键的B+树上，进行树的遍历匹配值过程，时间复杂度是O(N)。



## 索引覆盖、索引下推、前缀索引

**索引覆盖**：不需要回表的查询。`要的查询结果就是主键值且查询条件就是非主键索引字段`，即在索引树上的查询结果就是我们需要的结果。索引覆盖可以显著减少树的搜索次数，显著提升查询性能。

**索引下推**：MySQL5.6版本引入索引下推，就是在只能利用部分联合索引时，对剩余联合索引的字段（不符和最左匹配原则的字段）进行先判断，先过滤，通过先过滤来减少回表的次数。

**前缀索引**：对于列的值较长，比如BLOB、TEXT、VARCHAR，就必须建立前缀索引，即将值的前一部分作为索引。这样既可以节约空间，又可以提高查询效率。但无法使用前缀索引做 ORDER BY 和 GROUP BY，也无法使用前缀索引做覆盖扫描。



参考文献

https://zhuanlan.zhihu.com/p/113917726

https://blog.csdn.net/weixin_40475396/article/details/105465303
