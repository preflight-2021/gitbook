# MySql 锁

## **锁机制**

- 共享锁（读锁）：其他事务可以读，但不能写。

- 排他锁（写锁）：其他事务不能读取，也不能写。

  

## **锁**粒度

### 表级锁（table-level locking）

​	MyISAM 引擎采用的是表级锁。开销小，加锁快；不会出现死锁；锁定粒度大，发生锁冲突的概率最高，并发度最低。 

#### **MyISAM表级锁**

- 表共享读锁 （Table Read Lock）：不会阻塞其他用户对同一表的读请求，但会阻塞对同一表的写请求；
- 表独占写锁 （Table Write Lock）：会阻塞其他用户对同一表的读和写操作；

​	默认情况下，写锁比读锁具有更高的优先级：当一个锁释放时，这个锁会优先给写锁队列中等候的获取锁请求，然后再给读锁队列中等候的获取锁请求。可以设置改变读锁和写锁的优先级。

​	加锁方式：SELECT 自动加读锁，（UPDATE、DELETE、INSERT ）等加写锁，用 LOCK TABLE 命令给 MyISAM 表显式加锁（读锁、写锁都加）。

#### **InnoDB表级锁**

- 意向共享锁（IS）：事务在给一个数据行加共享锁（行锁）前必须先取得该表的 IS 锁。 

- 意向排他锁（IX）：事务在给一个数据行加排他锁（行锁）前必须先取得该表的 IX 锁。

  加锁方式：自动加锁。

  

### 页面锁

​	开销和加锁时间界于表锁和行锁之间；会出现死锁；锁定粒度界于表锁和行锁之间，并发度一般。

#### BDB 存储引擎才支持页面锁(暂不了解)



### 行级锁（row-level locking）

​	开销大，加锁慢；会出现死锁；锁定粒度最小，发生锁冲突的概率最低，并发度也最高。

#### **MyISAM不支持行级锁**

​	MyISAM不支持行级锁

#### **InnoDB行级锁**

- 共享锁（S）：允许一个事务去读一行，阻止其他事务获得相同数据集的排他锁。 其他 session  仍然可以查询记录，并也可以对该记录加 share mode 的共享锁。但是如果当前事务需要对该记录进行更新操作，则很有可能造成死锁。
- 排他锁（X）：允许获得排他锁的事务更新数据，阻止其他事务取得相同数据集的共享读锁和排他写锁。其他 session 可以查询该记录，但是不能对该记录加共享锁或排他锁，而是等待获得锁。

​	

加锁方式：

- 共享锁（S）：SELECT * FROM table_name WHERE ... **LOCK IN SHARE MODE**。 

- 排他锁（X)：

  1、SELECT * FROM table_name WHERE ... **FOR UPDATE**。

  2、（UPDATE、DELETE、INSERT ）等自动加排他锁（X)。

兼容情况：

| 当前锁\|兼容性\|锁模式 | X    | IX   | S    | IS   |
| :--------------------: | ---- | ---- | ---- | ---- |
|         **X**          | 冲突 | 冲突 | 冲突 | 冲突 |
|         **IX**         | 冲突 | 兼容 | 冲突 | 兼容 |
|           S            | 冲突 | 冲突 | 兼容 | 兼容 |
|         **IS**         | 冲突 | 兼容 | 兼容 | 兼容 |

实现方式：

​	InnoDB 行锁是通过给索引上的索引项加锁来实现，不论是使用主键索引、唯一索引或普通索引，InnoDB 都会使用行锁来对数据加锁，只有通过索引条件检索数据，InnoDB 才使用行级锁，否则，InnoDB 将使用表锁！但是否使用索引来检索数据是由 MySQL  通过判断不同执行计划的代价来决定的，如果 MySQL 认为全表扫描效率更高，比如对一些很小的表，它就不会使用索引，这种情况下 InnoDB  将使用表锁，而不是行锁。



### 间隙锁

#### **InnoDB间隙锁**

​		用范围检索数据，并请求共享或排他锁时，InnoDB会给符合条件的已有数据记录的索引项加锁；对于键值在条件范围内但并不存在的记录，叫做“间隙（GAP)”，InnoDB也会对这个“间隙”加锁，这种锁机制就是所谓的间隙锁（Next-Key锁）。这种加锁机制会阻塞符合条件范围内键值的并发插入，这往往会造成严重的锁等待。因此，在实际应用开发中，尤其是并发插入比较多的应用，我们要尽量优化业务逻辑，尽量使用相等条件来访问更新数据，避免使用范围条件。

**InnoDB使用间隙锁的目的：**

1. 防止幻读，以满足相关隔离级别的要求；
2. 满足恢复和复制的需要：

MySQL 通过 BINLOG 录入执行成功的 INSERT、UPDATE、DELETE 等更新数据的 SQL 语句，并由此实现 MySQL  数据库的恢复和主从复制。MySQL 的恢复机制（复制其实就是在 Slave Mysql 不断做基于 BINLOG 的恢复）有以下特点：

一是 MySQL 的恢复是 SQL 语句级的，也就是重新执行 BINLOG 中的 SQL 语句。

二是 MySQL 的 Binlog 是按照事务提交的先后顺序记录的， 恢复也是按这个顺序进行的。

由此可见，MySQL 的恢复机制要求：在一个事务未提交前，其他并发事务不能插入满足其锁定条件的任何记录，也就是不允许出现幻读。



参考文献:  https://zhuanlan.zhihu.com/p/29150809
