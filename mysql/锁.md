# MySql 锁

## **锁机制**

- 共享锁（读锁）：其他事务可以读，但不能写。

- 排他锁（写锁）：其他事务不能读取，也不能写。

  

## **锁**粒度

### 表级锁（table-level locking）

​	MyISAM 引擎采用的是表级锁。开销小，加锁快；不会出现死锁；锁定粒度大，发生锁冲突的概率最高，并发度最低。 

#### **MyISAM表级锁**

- 表共享读锁 （Table Read Lock）：不会阻塞其他用户对同一表的读请求，但会阻塞对同一表的写请求；
- 表独占写锁 （Table Write Lock）：会阻塞其他用户对同一表的读和写操作；

​	默认情况下，写锁比读锁具有更高的优先级：当一个锁释放时，这个锁会优先给写锁队列中等候的获取锁请求，然后再给读锁队列中等候的获取锁请求。可以设置改变读锁和写锁的优先级。

​	加锁方式：SELECT 自动加读锁，（UPDATE、DELETE、INSERT ）等加写锁，用 LOCK TABLE 命令给 MyISAM 表显式加锁（读锁、写锁都加）。

#### **InnoDB表级锁**

- 意向共享锁（IS）：事务在给一个数据行加共享锁（行锁）前必须先取得该表的 IS 锁。 

- 意向排他锁（IX）：事务在给一个数据行加排他锁（行锁）前必须先取得该表的 IX 锁。

  加锁方式：自动加锁。

  

### 页面锁

​	开销和加锁时间界于表锁和行锁之间；会出现死锁；锁定粒度界于表锁和行锁之间，并发度一般。

#### BDB 存储引擎才支持页面锁(暂不了解)



### 行级锁（row-level locking）

​	开销大，加锁慢；会出现死锁；锁定粒度最小，发生锁冲突的概率最低，并发度也最高。

#### **MyISAM不支持行级锁**



#### **InnoDB行级锁**

- 共享锁（S）：允许一个事务去读一行，阻止其他事务获得相同数据集的排他锁。 其他 session  仍然可以查询记录，并也可以对该记录加 share mode 的共享锁。但是如果当前事务需要对该记录进行更新操作，则很有可能造成死锁。
- 排他锁（X）：允许获得排他锁的事务更新数据，阻止其他事务取得相同数据集的共享读锁和排他写锁。其他 session 可以查询该记录，但是不能对该记录加共享锁或排他锁，而是等待获得锁。

加锁方式：

- 共享锁（S）：SELECT * FROM table_name WHERE ... **LOCK IN SHARE MODE**。 

- 排他锁（X)：

  1、SELECT * FROM table_name WHERE ... **FOR UPDATE**。

  2、（UPDATE、DELETE、INSERT ）等自动加排他锁（X)。

兼容情况：

| 当前锁\|兼容性\|锁模式 | X    | IX   | S    | IS   |
| :--------------------: | ---- | ---- | ---- | ---- |
|         **X**          | 冲突 | 冲突 | 冲突 | 冲突 |
|         **IX**         | 冲突 | 兼容 | 冲突 | 兼容 |
|         **S**          | 冲突 | 冲突 | 兼容 | 兼容 |
|         **IS**         | 冲突 | 兼容 | 兼容 | 兼容 |

实现方式：

​	InnoDB 行锁是通过给索引上的索引项加锁来实现，不论是使用主键索引、唯一索引或普通索引，InnoDB 都会使用行锁来对数据加锁，只有通过索引条件检索数据，InnoDB 才使用行级锁，否则，InnoDB 将使用表锁！但是否使用索引来检索数据是由 MySQL  通过判断不同执行计划的代价来决定的，如果 MySQL 认为全表扫描效率更高，比如对一些很小的表，它就不会使用索引，这种情况下 InnoDB  将使用表锁，而不是行锁。



### 间隙锁

#### **InnoDB间隙锁**

​		用范围检索数据，并请求共享或排他锁时，InnoDB会给符合条件的已有数据记录的索引项加锁；对于键值在条件范围内但并不存在的记录，叫做”间隙（GAP)”，InnoDB也会对这个“间隙”加锁，这种锁机制就是所谓的间隙锁（Next-Key锁）。这种加锁机制会阻塞符合条件范围内键值的并发插入，这往往会造成严重的锁等待。因此，在实际应用开发中，尤其是并发插入比较多的应用，我们要尽量优化业务逻辑，尽量使用相等条件来访问更新数据，避免使用范围条件。

使用目的：

1. 防止幻读，以满足相关隔离级别的要求；

2. 满足恢复和复制的需要：

   MySQL 通过 BINLOG 录入执行成功的 INSERT、UPDATE、DELETE 等更新数据的 SQL 语句，并由此实现 MySQL  数据库的恢复和主从复制。MySQL 的恢复机制（复制其实就是在 Slave Mysql 不断做基于 BINLOG 的恢复）有以下特点：

   一是 MySQL 的恢复是 SQL 语句级的，也就是重新执行 BINLOG 中的 SQL 语句。

   二是 MySQL 的 Binlog 是按照事务提交的先后顺序记录的， 恢复也是按这个顺序进行的。

由此可见，MySQL 的恢复机制要求：在一个事务未提交前，其他并发事务不能插入满足其锁定条件的任何记录，也就是不允许出现幻读。



## **死锁（Deadlock Free）**

死锁是指两个或多个事务在同一资源上相互占用，并请求锁定对方占用的资源，从而导致恶性循环。

- **死锁产生：**

  - 当事务试图以不同的顺序锁定资源时，就可能产生死锁。多个事务同时锁定同一个资源时也可能会产生死锁。 
  - 锁的行为和顺序和存储引擎相关。以同样的顺序执行语句，有些存储引擎会产生死锁有些不会——死锁有双重原因：真正的数据冲突；存储引擎的实现方式。

- **检测死锁：**数据库系统实现了各种死锁检测和死锁超时的机制。InnoDB存储引擎能检测到死锁的循环依赖并立即返回一个错误。

- **死锁恢复：**死锁发生以后，只有部分或完全回滚其中一个事务，才能打破死锁，InnoDB目前处理死锁的方法是，将持有最少行级排他锁的事务进行回滚。所以事务型应用程序在设计时必须考虑如何处理死锁，多数情况下只需要重新执行因死锁回滚的事务即可。 

- **外部锁的死锁检测：**发生死锁后，InnoDB 一般都能自动检测到，并使一个事务释放锁并回退，另一个事务获得锁，继续完成事务。但在涉及外部锁，或涉及表锁的情况下，InnoDB  并不能完全自动检测到死锁， 这需要通过设置锁等待超时参数 innodb_lock_wait_timeout 来解决 

- **死锁影响性能：**死锁会影响性能而不是会产生严重错误，因为InnoDB会自动检测死锁状况并回滚其中一个受影响的事务。在高并发系统上，当许多线程等待同一个锁时，死锁检测可能导致速度变慢。  有时当发生死锁时，禁用死锁检测（使用innodb_deadlock_detect配置选项）可能会更有效，这时可以依赖innodb_lock_wait_timeout设置进行事务回滚。 

- **避免死锁：**

  - 在事务开始时通过为预期要修改的每个元祖（行）使用排它锁，即使这些行的更改语句是在之后才执行的。
  - 如果要更新记录，应该直接申请足够级别的锁，即排他锁，而不应先申请共享锁、更新时再申请排他锁，因为这时候当用户再申请排他锁时，其他事务可能又已经获得了相同记录的共享锁，从而造成锁冲突，甚至死锁。
  - 如果事务需要修改或锁定多个表，则应在每个事务中以相同的顺序使用加锁语句。 应尽量约定以相同的顺序来访问表，这样可以大大降低产生死锁的机会。
  - 精心设计索引， 并尽量使用索引访问数据， 使加锁更精确， 从而减少锁冲突的机会。
  - 改变事务隔离级别。

参考文献:  https://zhuanlan.zhihu.com/p/29150809

